<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Idol Live Show Line Edition</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); color: white; font-size: 2em; z-index: 10; cursor: pointer; }
    #controls { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 14px; z-index: 11; display: flex; gap: 10px; align-items: center; }
    #controls label { display: flex; align-items: center; gap: 4px; }
    #controls input[type=range] { width: 100px; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">クリックしてライブを開始</div>
  <div id="controls" style="display:none;">
    <label>Idol Glow <span id="idolBloomVal"></span><input type="range" id="idolBloom" min="0" max="3" step="0.1" value="1.4"></label>
    <label>Confetti Glow <span id="confettiBloomVal"></span><input type="range" id="confettiBloom" min="0" max="3" step="0.1" value="1.9"></label>
    <label>Beat Effect <span id="beatIntensityVal"></span><input type="range" id="beatIntensity" min="0" max="1" step="0.05" value="0.65"></label>
    <label>Strobe <span id="strobeIntensityVal"></span><input type="range" id="strobeIntensity" min="0" max="1" step="0.05" value="0.35"></label>
    <label>Spot Brightness <span id="spotIntensityVal"></span><input type="range" id="spotIntensity" min="0" max="1" step="0.05" value="0.25"></label>
    <label>Line Width <span id="lineWidthVal"></span><input type="range" id="lineWidth" min="0.001" max="1.0" step="0.001" value="1.000"></label>
    <label>Zoom <span id="zoomVal"></span><input type="range" id="cameraZoom" min="2" max="10" step="0.1" value="4.0"></label>
  </div>
  <audio id="bgm" src="bgm.wav" preload="auto"></audio>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/shaders/FXAAShader.js';
    import { Line2 } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/lines/Line2.js';
    import { LineMaterial } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/lines/LineMaterial.js';
    import { LineGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/lines/LineGeometry.js';
    import lines1 from './lines1.js';
    import lines2 from './lines2.js';
    import lines3 from './lines3.js';
    import lines4 from './lines4.js';

    const linesSets = [lines1, lines2, lines3, lines4];

    // Setup scene and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.enableZoom = true;
    controls.zoomSpeed = 1.0;
    controls.minDistance = 2.0;
    controls.maxDistance = 10.0;

    // Explicit pinch-zoom support (two-finger): dolly along camera Z
    let isPinching = false;
    let pinchStartDist = 0;
    let pinchStartZ = camera.position.z;
    const minZ = 2.0;
    const maxZ = 10.0;

    // Zoom slider handles
    const zoomSlider = document.getElementById('cameraZoom');
    const zoomVal = document.getElementById('zoomVal');

    function distance2(t0, t1) {
      const dx = t0.clientX - t1.clientX;
      const dy = t0.clientY - t1.clientY;
      return Math.hypot(dx, dy);
    }

    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        isPinching = true;
        pinchStartDist = distance2(e.touches[0], e.touches[1]);
        pinchStartZ = camera.position.z;
        e.preventDefault();
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (isPinching && e.touches.length === 2) {
        const dist = distance2(e.touches[0], e.touches[1]);
        const factor = pinchStartDist / Math.max(1, dist);
        const newZ = Math.min(maxZ, Math.max(minZ, pinchStartZ * factor));
        camera.position.z = newZ;
        camera.updateProjectionMatrix();
        syncLabels();
        e.preventDefault();
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchend', () => {
      if (isPinching) {
        isPinching = false;
      }
    });

    // Zoom slider -> camera
    zoomSlider.addEventListener('input', (e) => {
      const z = parseFloat(e.target.value);
      camera.position.z = Math.min(maxZ, Math.max(minZ, z));
      camera.updateProjectionMatrix();
      syncLabels();
    });

    // Wheel zoom sync -> labels
    renderer.domElement.addEventListener('wheel', () => {
      // OrbitControls already applied. Just sync display.
      camera.position.z = Math.min(maxZ, Math.max(minZ, camera.position.z));
      syncLabels();
    }, { passive: true });

    // Rebuild: beat-cut thin "spotlight" stripes (screen-like beams, not true lights)
    function createStripTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      // vertical fade (both ends invisible)
      const vgrad = ctx.createLinearGradient(0, 0, 0, size);
      vgrad.addColorStop(0.00, 'rgba(255,255,255,0)');
      vgrad.addColorStop(0.15, 'rgba(255,255,255,0.35)');
      vgrad.addColorStop(0.50, 'rgba(255,255,255,0.85)');
      vgrad.addColorStop(0.85, 'rgba(255,255,255,0.35)');
      vgrad.addColorStop(1.00, 'rgba(255,255,255,0)');
      ctx.fillStyle = vgrad;
      ctx.fillRect(0, 0, size, size);
      // horizontal soft edges (thin center)
      const img = ctx.getImageData(0, 0, size, size);
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const nx = (x / (size - 1)) * 2 - 1; // -1..1
          const falloff = Math.exp(-6 * nx * nx); // gaussian
          const i = (y * size + x) * 4;
          img.data[i + 3] = Math.min(255, img.data[i + 3] * falloff);
        }
      }
      ctx.putImageData(img, 0, 0);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;
      return tex;
    }
    const stripTex = createStripTexture();
    const stripesGroup = new THREE.Group();
    scene.add(stripesGroup);
    const stripes = [];
    const STRIPE_COUNT = 8; // 同時に複数表示
    const basePlane = new THREE.PlaneGeometry(1, 1);
    function spawnStripes() {
      // clear existing
      while (stripes.length) {
        const m = stripes.pop();
        stripesGroup.remove(m.mesh);
        m.mesh.geometry.dispose();
        m.mesh.material.dispose();
      }
      for (let i = 0; i < STRIPE_COUNT; i++) {
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          map: stripTex,
          transparent: true,
          opacity: 0.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          side: THREE.DoubleSide,
        });
        const mesh = new THREE.Mesh(basePlane.clone(), mat);
        stripesGroup.add(mesh);
        stripes.push({ mesh });
      }
    }
    spawnStripes();

    function randomizeStripes(beatIndex, targetVec) {
      const center = (targetVec && targetVec.isVector3) ? targetVec.clone() : new THREE.Vector3(0, 1.0, 0);
      for (let i = 0; i < stripes.length; i++) {
        const s = stripes[i];
        // random yaw behind camera (-PI..0)
        const yaw = -Math.PI * Math.random();
        const radius = 2.0 + Math.random() * 1.8;
        const y = 0.5 + Math.random() * 1.8;
        const pos = new THREE.Vector3(Math.cos(yaw) * radius, y, Math.sin(yaw) * radius);
        s.mesh.position.copy(pos);
        // look at near center with a bit of random offset to get pitch variety
        const tgt = center.clone();
        tgt.x += (Math.random() - 0.5) * 0.6;
        tgt.y += (Math.random() - 0.5) * 0.8;
        tgt.z += (Math.random() - 0.5) * 0.6;
        s.mesh.lookAt(tgt);
        // width and length per stripe
        s.widthBase = 0.15 + Math.random() * 0.5; // 細い
        s.length = 40 + Math.random() * 30; // 終点が確実に画面外
        s.widenPulse = 1.0 + Math.random() * 1.4;
        s.mesh.scale.set(s.widthBase, s.length, 1);
        // color per stripe
        const h = Math.random();
        const color = new THREE.Color().setHSL(h, 1.0, 0.55);
        s.mesh.material.color.copy(color);
      }
    }

    // Post-processing composer with bloom and FXAA
    const composer = new EffectComposer(renderer);
    // Pop, geometric background via full-screen shader
    const BackgroundShader = {
      uniforms: {
        time: { value: 0 },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        beat: { value: 0 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform float time; 
        uniform vec2 resolution; 
        uniform float beat; 
        varying vec2 vUv;

        // palette
        vec3 palette(float t){
          return 0.55 + 0.45*cos(6.28318*(vec3(0.0,0.33,0.67)+t));
        }

        float vignette(vec2 uv){
          uv = uv*2.0-1.0; 
          float r = dot(uv,uv);
          return smoothstep(1.2, 0.2, r);
        }

        float stripes(vec2 uv){
          // rotate 35deg
          float c = cos(0.61), s = sin(0.61);
          mat2 R = mat2(c,-s,s,c);
          uv = R*(uv*2.0-1.0);
          float w = 8.0; // stripe density
          float m = 0.5 + 0.5*cos((uv.x*w - time*0.3) );
          return smoothstep(0.45, 0.55, m);
        }

        float dots(vec2 uv){
          vec2 g = fract(uv*vec2(8.0, 12.0) + vec2(0.0, time*0.15)) - 0.5;
          float d = length(g);
          float base = smoothstep(0.25, 0.0, d);
          return base;
        }

        void main(){
          vec2 uv = vUv;
          // soft gradient base
          vec3 col = mix(vec3(0.03,0.02,0.05), vec3(0.06,0.05,0.08), uv.y);
          // animated stripes
          float st = stripes(uv);
          vec3 scol = palette(uv.y*0.5 + time*0.03);
          col += scol * st * (0.10 + 0.15*beat);
          // moving dots
          float dt = dots(uv);
          vec3 dcol = palette(uv.x*0.7 + 0.2*time);
          col += dcol * dt * (0.07 + 0.10*beat);
          // vignette to keep edges dark
          col *= vignette(uv);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    };
    const bgPass = new ShaderPass(BackgroundShader);
    composer.addPass(bgPass);
    const renderPass = new RenderPass(scene, camera);
    renderPass.clear = false; // keep background pass
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.5, 0.0);
    composer.addPass(bloomPass);
    const fxaaPass = new ShaderPass(FXAAShader);
    const pixelRatio = renderer.getPixelRatio();
    fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
    fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
    composer.addPass(fxaaPass);

    // Global variables for controls
    const idolBloomVal = document.getElementById('idolBloomVal');
    const confettiBloomVal = document.getElementById('confettiBloomVal');
    const beatIntensityVal = document.getElementById('beatIntensityVal');
    const strobeIntensityVal = document.getElementById('strobeIntensityVal');
    const spotIntensityVal = document.getElementById('spotIntensityVal');
    const lineWidthVal = document.getElementById('lineWidthVal');

    let idolGlow = parseFloat(document.getElementById('idolBloom').value);
    let confettiGlow = parseFloat(document.getElementById('confettiBloom').value);
    let beatIntensity = parseFloat(document.getElementById('beatIntensity').value);
    let baseLineWidth = parseFloat(document.getElementById('lineWidth').value);
    let strobeIntensity = parseFloat(document.getElementById('strobeIntensity').value);
    let spotIntensity = parseFloat(document.getElementById('spotIntensity').value);

    function syncLabels() {
      idolBloomVal.textContent = idolGlow.toFixed(2);
      confettiBloomVal.textContent = confettiGlow.toFixed(2);
      beatIntensityVal.textContent = beatIntensity.toFixed(2);
      strobeIntensityVal.textContent = strobeIntensity.toFixed(2);
      spotIntensityVal.textContent = spotIntensity.toFixed(2);
      lineWidthVal.textContent = baseLineWidth.toFixed(3);
      const zv = document.getElementById('zoomVal');
      const zs = document.getElementById('cameraZoom');
      if (zv && zs) {
        zv.textContent = camera.position.z.toFixed(1);
        zs.value = camera.position.z.toFixed(1);
      }
    }
    syncLabels();

    document.getElementById('idolBloom').addEventListener('input', (e) => {
      idolGlow = parseFloat(e.target.value);
      syncLabels();
    });
    document.getElementById('confettiBloom').addEventListener('input', (e) => {
      confettiGlow = parseFloat(e.target.value);
      syncLabels();
    });
    document.getElementById('beatIntensity').addEventListener('input', (e) => {
      beatIntensity = parseFloat(e.target.value);
      syncLabels();
    });
    document.getElementById('lineWidth').addEventListener('input', (e) => {
      baseLineWidth = parseFloat(e.target.value);
      syncLabels();
    });
    document.getElementById('strobeIntensity').addEventListener('input', (e) => {
      strobeIntensity = parseFloat(e.target.value);
      syncLabels();
    });
    document.getElementById('spotIntensity').addEventListener('input', (e) => {
      spotIntensity = parseFloat(e.target.value);
      syncLabels();
    });

    // Create confetti particle system (points)
    const confCount = 1200;
    const confGeometry = new THREE.BufferGeometry();
    const confPositions = new Float32Array(confCount * 3);
    const confColors = new Float32Array(confCount * 3);
    const confVelocities = new Float32Array(confCount * 3);
    for (let i = 0; i < confCount; i++) {
      const idx = i * 3;
      confPositions[idx] = (Math.random() - 0.5) * 8;
      confPositions[idx + 1] = Math.random() * 6 + 2;
      confPositions[idx + 2] = (Math.random() - 0.5) * 8;
      confVelocities[idx] = (Math.random() - 0.5) * 0.03;
      confVelocities[idx + 1] = - (0.02 + Math.random() * 0.03);
      confVelocities[idx + 2] = (Math.random() - 0.5) * 0.03;
      const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.7);
      confColors[idx] = color.r;
      confColors[idx + 1] = color.g;
      confColors[idx + 2] = color.b;
    }
    confGeometry.setAttribute('position', new THREE.BufferAttribute(confPositions, 3));
    confGeometry.setAttribute('color', new THREE.BufferAttribute(confColors, 3));
    const baseConfettiSize = 0.05;
    const confMaterial = new THREE.PointsMaterial({ size: baseConfettiSize, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false });
    const confetti = new THREE.Points(confGeometry, confMaterial);
    confetti.scale.set(1.5, 1.5, 1.5);
    scene.add(confetti);

    // Create idol figures from lines
    function createFigure(linesData, hue) {
      const group = new THREE.Group();
      const color = new THREE.Color(`hsl(${hue % 360}, 100%, 70%)`);
      linesData.forEach(polyline => {
        const flat = [];
        polyline.forEach(p => { flat.push(p[0], p[1], p[2]); });
        const geometry = new LineGeometry();
        geometry.setPositions(flat);
        const mat = new LineMaterial({
          color: color,
          linewidth: baseLineWidth,
          transparent: true,
          opacity: 0.9
        });
        mat.resolution.set(window.innerWidth, window.innerHeight);
        const line = new Line2(geometry, mat);
        line.computeLineDistances();
        group.add(line);
      });
      // enlarge figure
      group.scale.set(2.2, 2.2, 2.2);
      return group;
    }

    const figures = [
      createFigure(lines1, 0),
      createFigure(lines2, 90),
      createFigure(lines3, 180),
      createFigure(lines4, 270),
    ];
    let currentFigureIndex = 0;
    scene.add(figures[currentFigureIndex]);

    // Setup audio and beat switching
    const audio = document.getElementById('bgm');
    audio.loop = true;
    const bpm = 120;
    const beatsPerSwitch = 4; // figure切替は従来通り4拍ごと
    const beatDuration = 60 / bpm; // 1拍の長さ(秒)
    const switchInterval = beatDuration * beatsPerSwitch;
    let lastSwitch = 0;
    // 1拍ごとのスパイク用ステート
    let lastBeatIndex = -1;
    let beatFlash = 0;            // 0..1 で減衰
    const beatFlashDecayPerSec = 6; // 大きいほど早く収束(約0.16秒で1→0)
    let lastAudioTime = 0;
    const baseCameraPos = new THREE.Vector3(0, 0, 4);
    const shakeIntensity = 0.02;

    // Overlay to start
    const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', () => {
      overlay.style.display = 'none';
      document.getElementById('controls').style.display = 'flex';
      audio.play();
      lastSwitch = audio.currentTime;
      const bbox = new THREE.Box3().setFromObject(figures[currentFigureIndex]);
      const center = new THREE.Vector3();
      bbox.getCenter(center);
      randomizeStripes(0, center);
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      if (bgPass && bgPass.uniforms && bgPass.uniforms.resolution) {
        bgPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      }
      // update resolution uniform for all line materials
      figures.forEach(fig => {
        fig.traverse(obj => {
          if (obj.material && obj.material.isLineMaterial) {
            obj.material.resolution.set(window.innerWidth, window.innerHeight);
          }
        });
      });
      const pixelRatio = renderer.getPixelRatio();
      fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
      fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const t = audio.currentTime;
      // drive background
      if (bgPass && bgPass.uniforms) {
        bgPass.uniforms.time.value = t;
        bgPass.uniforms.beat.value = beatFlash;
      }

      // per-beat spike detection
      const currentBeatIndex = Math.floor(t / beatDuration);
      if (!audio.paused && currentBeatIndex !== lastBeatIndex) {
        lastBeatIndex = currentBeatIndex;
        beatFlash = 1; // ビート頭で最大値に
        const bbox = new THREE.Box3().setFromObject(figures[currentFigureIndex]);
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        randomizeStripes(currentBeatIndex, center);
      }

      // figure switching (従来通り4拍ごと)
      if (!audio.paused && t - lastSwitch >= switchInterval) {
        scene.remove(figures[currentFigureIndex]);
        currentFigureIndex = (currentFigureIndex + 1) % figures.length;
        scene.add(figures[currentFigureIndex]);
        lastSwitch += switchInterval;
      }

      // compute dt from audio timeline and decay spike
      const dt = Math.max(0, t - lastAudioTime);
      lastAudioTime = t;
      beatFlash = Math.max(0, beatFlash - dt * beatFlashDecayPerSec);

      // Beat effect: sharp pulse on scale and line width
      // Beat effect: sharp pulse on scale and line width
      const figure = figures[currentFigureIndex];
      // Scale pulse (breathing)
      const scalePulse = 1 + (0.05 + 0.07 * beatIntensity) * beatFlash;
      figure.scale.set(2.2 * scalePulse, 2.2 * scalePulse, 2.2 * scalePulse);
      // Subtle rotation punch per beat for dynamism
      const rotJitter = 0.02 * beatFlash * (0.5 + beatIntensity);
      figure.rotation.z += rotJitter * (Math.random() > 0.5 ? 1 : -1);
      figure.traverse(obj => {
        if (obj.material && obj.material.isLineMaterial) {
          // Linewidth pulse (softer)
          obj.material.linewidth = baseLineWidth * (1 + (beatIntensity * 1.2) * beatFlash);
          // (dashed off) keep lines continuous
        }
      });
      // rotate confetti slowly but not figure
      confetti.rotation.y += 0.002;
      // animate confetti
      const pos = confGeometry.getAttribute('position');
      for (let i = 0; i < confCount; i++) {
        const idx = i * 3;
        confPositions[idx] += confVelocities[idx];
        confPositions[idx + 1] += confVelocities[idx + 1];
        confPositions[idx + 2] += confVelocities[idx + 2];
        if (confPositions[idx + 1] < -3) {
          confPositions[idx] = (Math.random() - 0.5) * 8;
          confPositions[idx + 1] = Math.random() * 6 + 2;
          confPositions[idx + 2] = (Math.random() - 0.5) * 8;
        }
      }
      pos.needsUpdate = true;
      // Update bloom strength with gentler per-beat spike
      const flashScale = 0.4 + 0.3 * beatIntensity; // eye-friendly
      bloomPass.strength = idolGlow + flashScale * beatFlash;

      // Confetti: soften strobe
      confMaterial.size = baseConfettiSize * (1 + 0.7 * beatFlash);
      confMaterial.opacity = Math.min(1.0, (confettiGlow / 2.0) * (0.85 + 0.25 * beatFlash));

      // Light camera shake on beat
      camera.position.copy(baseCameraPos);
      camera.position.x += (Math.random() - 0.5) * shakeIntensity * beatFlash;
      camera.position.y += (Math.random() - 0.5) * shakeIntensity * beatFlash;

      // Spotlight stripes opacity and widen per-beat
      const baseO = 0.45 * spotIntensity; // 0で消灯
      for (let i = 0; i < stripes.length; i++) {
        const s = stripes[i];
        const mat = s.mesh.material;
        mat.opacity = Math.min(0.95, (baseO + 0.7 * beatFlash * spotIntensity) * (0.2 + 0.8 * strobeIntensity));
        const w = s.widthBase * (1.0 + beatFlash * strobeIntensity * s.widenPulse);
        s.mesh.scale.set(w, s.length, 1);
      }
      // Update controls in case they changed externally
      controls.update();
      composer.render();
    }
    animate();
  </script>
</body>
</html>
